#include <stdio.h>
#include <iostream>
#include <vector>
#include <math.h>

#include <ros/ros.h>
#include "pcl_ros/point_cloud.h"

#include <pcl/point_types.h>
#include <pcl/visualization/pcl_visualizer.h>
#include <pcl/io/pcd_io.h>
#include <pcl/common/common_headers.h>


#include <kin.h>

typedef pcl::PointXYZRGB PointT;
typedef pcl::PointCloud<PointT> PointCloudT;


using std::cout;
using std::endl;





ros::Subscriber sub;
ros::Publisher  pub;

KinectIN kin;

pcl::visualization::PCLVisualizer viewer_1("PCL Viewer_1");


void redraw_frame(PointCloudT::Ptr cloud)
{
	viewer_1.removeAllPointClouds ();
	pcl::visualization::PointCloudColorHandlerRGBField<PointT> rgb_in(cloud);
	viewer_1.addPointCloud<PointT> (cloud, rgb_in, "input_cloud");

	char text[50];
	sprintf(text, "Roll: %f\nPitch: %f\nYaw: Nan\nHeight: %f\n \n", kin.position.rotation.roll,
		    														kin.position.rotation.pitch,
		    														kin.position.distance_to_floor);
	viewer_1.updateText (text, 10, 10, 14, 1, 1, 1, "angles");
	viewer_1.spinOnce ();
};


void callback(const pcl::PointCloud<pcl::PointXYZ>::ConstPtr& xyz_cloud)
{
	PointCloudN::Ptr mls_cloud = kin.filter(xyz_cloud);
	pcl::PointIndices::Ptr inliers = kin.find_plane(mls_cloud);
	PointCloudT::Ptr segmented_cloud = kin.get_colored_cloud(mls_cloud, inliers);

	//redraw_frame(segmented_cloud);

	viewer_1.removeAllPointClouds ();
	pcl::visualization::PointCloudColorHandlerRGBField<PointT> rgb_in(segmented_cloud);
	viewer_1.addPointCloud<PointT> (segmented_cloud, rgb_in, "input_cloud");

	//char text[50];
	//sprintf(text, "Roll: %f\nPitch: %f\nYaw: Nan\nHeight: %f\n \n", kin.position.rotation.roll,
	//	    														kin.position.rotation.pitch,
	//	    														kin.position.distance_to_floor);
	//viewer_1.updateText (text, 10, 10, 14, 1, 1, 1, "angles");
	viewer_1.spinOnce ();

/*
	PointCloudT outcloud;
	for(int i = 0; i < segmented_cloud->points.size(); i++)
	{
		outcloud.points.push_back(segmented_cloud->points[i]);
	}
	outcloud.height = 1;
	outcloud.width = segmented_cloud->points.size();

	pub.publish(outcloud);
*/
};






int main (int argc, char** argv)
{
	ros::init (argc, argv, "ad_filter");

	ros::NodeHandle nh;
	std::string input_topic  = nh.resolveName("point_cloud_xyz_in" );
	std::string output_topic = nh.resolveName("point_cloud_xyzrgb_out");

	sub = nh.subscribe<pcl::PointCloud<pcl::PointXYZ> > (input_topic,  1, callback);
	pub = nh.advertise<pcl::PointCloud<pcl::PointXYZRGB> > (output_topic, 1);

	viewer_1.addText ("Roll: Nan\nPitch: Nan\nYaw: Nan\n \n", 10, 10, 14, 1, 1, 1, "angles");





	ros::spin ();

	return 0;
}

/*

int main (int argc, char** argv)
{

	KinectIN kin;
	kin.start();

	pcl::visualization::PCLVisualizer viewer_1("PCL Viewer_1");
	pcl::visualization::PCLVisualizer viewer_2("PCL Viewer_2");

	//pcl::PointIndices::Ptr inliers = pcl::PointIndices::Ptr (new pcl::PointIndices);
	viewer_2.addText ("Roll: Nan\nPitch: Nan\nYaw: Nan\n \n", 10, 10, 14, 1, 1, 1, "angles");

	while (!viewer_2.wasStopped())
	{
		PointCloudT::Ptr cloud = kin.next_frame_RGBA ();
		PointCloudS::Ptr simple_cloud = kin.next_frame_XYZ();
		PointCloudN::Ptr mls_cloud = kin.filter(simple_cloud);
		pcl::PointIndices::Ptr inliers = kin.find_plane(mls_cloud);
		PointCloudT::Ptr segmented_cloud = kin.get_colored_cloud(mls_cloud, inliers);

		viewer_1.removeAllPointClouds ();
		viewer_2.removeAllPointClouds ();

		pcl::visualization::PointCloudColorHandlerRGBField<PointT> rgb_in(cloud);
		viewer_1.addPointCloud<PointT> (cloud, rgb_in, "input_cloud");
		pcl::visualization::PointCloudColorHandlerRGBField<PointT> rgb_seg(segmented_cloud);
	    viewer_2.addPointCloud<PointT> (segmented_cloud, rgb_seg, "input_cloud");

	    char text[50];
	    sprintf(text, "Roll: %f\nPitch: %f\nYaw: Nan\nHeight: %f\n \n", kin.position.rotation.roll,
	    																kin.position.rotation.pitch,
	    																kin.position.distance_to_floor);
	    viewer_2.updateText (text, 10, 10, 14, 1, 1, 1, "angles");



		viewer_1.spinOnce ();
		viewer_2.spinOnce ();

		kin.resume ();
	}


    return 0;
}

*/
