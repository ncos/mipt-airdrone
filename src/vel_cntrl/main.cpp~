#include <stdio.h>
#include <iostream>
#include <vector>
#include <math.h>

#include <ros/ros.h>
#include <geometry_msgs/Twist.h>
#include <visualization_msgs/Marker.h>

#include "pcl_ros/point_cloud.h"
#include <pcl/point_types.h>
#include <pcl/io/pcd_io.h>
#include <pcl/common/common_headers.h>
#include <pcl/ModelCoefficients.h>

#include "RANSAC.h"

using std::cout;
using std::cerr;
using std::endl;

ros::Subscriber sub;
ros::Publisher  pub_mrk;
ros::Publisher  pub_vel;
bool lost;

PID pid_ang(0.1, 0.01, 0.01);
PID pid_vel(1.0, 0.5, 0.5);

visualization_msgs::Marker line_list;



void add_line(pcl::ModelCoefficients::Ptr coefficients)
{
    geometry_msgs::Point p;
    p.y = -coefficients->values[0];
    p.z =  coefficients->values[1];
    p.x =  coefficients->values[2];

    line_list.points.push_back(p);

    p.y = p.y - 10 * coefficients->values[3];
    p.z = p.z + 10 * coefficients->values[4];
    p.x = p.x + 10 * coefficients->values[5];

    line_list.points.push_back(p);

    p.y = 0;
    p.z = 0;
    p.x = 0;

    line_list.points.push_back(p);

    p.y = -coefficients->values[3];
    p.z =  coefficients->values[4];
    p.x =  coefficients->values[5];

    line_list.points.push_back(p);

};

void return_to_wall(const pcl::PointCloud<pcl::PointXYZ>::ConstPtr& cloud)
{
    pcl::ModelCoefficients::Ptr coefficients = find_line (cloud, 0, 60);

    double angle;
    if (coefficients->values[3] == 0)
    {
    	if(coefficients->values[5] < 0) angle = -90;
    	else angle = 90;
    }
    else angle = atan(coefficients->values[5]/coefficients->values[3])*180.0/PI;

    geometry_msgs::Twist base_cmd;
    base_cmd.angular.z = - pid_ang.get_output(0, angle);
    cerr << "Angle: " << angle << "   " << base_cmd.angular.z << endl;





    pub_vel.publish(base_cmd);
};

void callback(const pcl::PointCloud<pcl::PointXYZ>::ConstPtr& cloud)
{
    line_list.header.stamp = ros::Time::now();
    line_list.points.clear();

    if(lost) return_to_wall(cloud);
    else
    {

    }
/*

    pcl::ModelCoefficients::Ptr coefficients = find_line (cloud, 0);

    double angle = atan(coefficients->values[5]/coefficients->values[3])*180.0/PI;

    cerr << coefficients->values[3] << "  "
    	 << coefficients->values[4] << "  "
    	 << coefficients->values[5] << "  "
    	 << "Angle: " << angle
    	 << endl;

    add_line(coefficients);
*/
    pub_mrk.publish(line_list);
};



int main( int argc, char** argv )
{
  ros::init(argc, argv, "laserscan_server");
  ros::NodeHandle nh;
  lost = true;


  std::string input_topic      = nh.resolveName("/shrinker/depth/laser_points");
  std::string output_topic_mrk = nh.resolveName("visualization_marker");
  std::string output_topic_vel = nh.resolveName("/cmd_vel");

  sub     = nh.subscribe<pcl::PointCloud<pcl::PointXYZ> > (input_topic,  1, callback);
  pub_mrk = nh.advertise<visualization_msgs::Marker >     (output_topic_mrk, 1 );
  pub_vel = nh.advertise<geometry_msgs::Twist >           (output_topic_vel, 1 );

  line_list.header.frame_id = "/camera_link";
  line_list.ns = "lines_ns";
  line_list.action = visualization_msgs::Marker::ADD;
  //line_list.pose.orientation.w = 0.0;
  line_list.id = 0;
  line_list.type = visualization_msgs::Marker::LINE_LIST;
  line_list.scale.x = 0.03;
  line_list.color.r = 0.0;
  line_list.color.g = 0.0;
  line_list.color.b = 1.0;
  line_list.color.a = 1.0;


  ros::spin ();

  return 0;
}
